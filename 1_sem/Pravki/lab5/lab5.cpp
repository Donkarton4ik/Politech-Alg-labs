/**
 * Практическое занятие №5. "Старые" потоковые функции стандартной библиотеки.
 * Указатели на функции. Структуры.
 */

#include <iostream>
//#include <cstdio>
#include "other.h"
#include <cmath>
#include "matrix.h"

Book book1;
int main()
{
    /**
     * Задание 1. "Старые" потоковые функции стандартной библиотеки.
     *
     * Эти функции использовались в языке C. Если вы будете писать программы на
     * нем, вам придется использовать их вместо std::cin и std::cout.
     */


    /**
     * Задание 1.1.
     *
     * С помощью функции scanf сформирйуте три коэффициента: A,B,C.
     */
    float A, B, C;
    printf("Через пробел введите коэффициенты А В С: ");
    scanf("%f %f %f", &A, &B, &C);

    /**
     * Задание 1.2.
     *
     * Выведите (красиво!) таблицу значений y=A*x*x + B*x + C при изменении x в
     * диапазоне -2 до +2 с шагом 0.5
     */

    printf("x\ty\n");
    for(float x=-2; x<=2; x+=0.5){
        float y = A*x*x + B*x + C;
        printf("%.2f  %.2f\n", x, y);
    }
    printf("\n\n");
    /**
     * Задание 2. Указатели на функции.
     */

    /**
     * Задание 2.1. Указатель на функцию. "Калькулятор".
     *
     * Напишите функции:
     * 1. add - принимает два значения double и возвращает сумму этих значений;
     * 2. sub- принимает два значения double и возвращает разность этих
     *    значений;
     * 3. mul - аналогично для умножения;
     * 4. div - аналогично для деления;
     * 5. а для возведения в степень можете использовать функцию стандартной
     *    библиотеки - pow(). 
     *
     * Подсказка 1: прототип функции находится в <cmath>.
     * Подсказка 2: стандартная библиотека предоставляет несколько
     * перегруженных вариантов этой функции, а Вам потребуется сформировать
     * указатель на double pow(double, double).
     *
     * Предоставьте пользователю следующую возможность:
     *
     * - пока пользователь хочет пользоваться услугами вашего калькулятора, он
     *   может вводить два значения и знак операции а вы выводите результат. 
     * - результат получаете посредством вызова соответствующей вашей функции
     *   по указателю.
     * - предусмотрите возможность ввода непредусмотренного знака операции.
     */
    char ch21;
    double A21, B21, otv21;
    std::cout<< "Задание 2.1" << std::endl;
    std::cout<< "В калькуляторе доступны операции: + - * / ^" << std::endl;
    std::cout<< "Для выхода из калькулятора введите $" << std::endl;
    char oper[6] = "+-*/^"; // TODO: зачем это?
    while(true){
        std::cout<< "Введите через пробел операцию и переменные / знак $: ";
        std::cin>> ch21;
        if(ch21=='$'){
            std::cout<<"Завершение работы..."<< std::endl;
            break;
        }

        bool flag21 = false;
        for(int i=0; i<5; i++){ //проверка корректности первого символа
            if(oper[i]==ch21){
                flag21 = true;
                break;
            }
        }

        if(!(flag21 && (std::cin>> A21>> B21))){ //если первый символ не операция, а 2 и 3 не числа (не удается записать)
            std::cout<<"Ошибка ввода!"<< std::endl;
            std::cin.clear(); //очищает ошибку cin
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); //очищает cin
            continue;
        }

        bool nulik = true;

        switch (ch21)
        {
        case '+':
            otv21 = cal(add, A21, B21);
            break;
        case '-':
            otv21 = cal(sub, A21, B21);
            break;
        case '*':
            otv21 = cal(mul, A21, B21);
            break;
        case '/':
            if(B21!=0){otv21 = cal(div, A21, B21);}
            else{nulik=false;}
            break;
        case '^':
            otv21 = cal(pow, A21, B21);
            break;
        }

        if(nulik){
            std::cout<< "Значение выражения: "<< otv21 << std::endl;
        }
        else{
            std::cout<< "Деление на 0!"<< std::endl;
        }
    }

    std::cout<< std::endl;
    std::cout<< std::endl;
    /**
     * Задание 2.2. Указатель на функцию в качестве аргумента.
     *
     * Дана заготовка функции сортировки любых объектов - sort.
     *
     * Функция принимает следующие параметры:
     * 1. указатель на первый сортируемый элемент
     * 2. количество сортируемых элементов
     * 3. размер элемента в байтах
     * 4. указатель на функцию перестановки элементов
     * 5. указатель на функцию сравнения элементов
     */

    /**
     * Задание 2.2.1.
     *
     * Напишите функцию перестановки двух целых значений - swap_int, которая
     * принимает два void указателя и меняет значения местами.
     *
     * Напишите функцию сравнения двух целых значений - CmpInt, которая
     * принимает два void указателя и возвращает int результат сравнения:  
     * <0 - первый элемент меньше, чем второй;
     * =0 - равны;
     * >0 - первый элемент больше, чем второй.
     *
     * Используйте эти функции в функции сортировки.
     */
    {
        int nAr[8]= {789, 56, -48, 52, 1863, -2, 7, 1};   //массив для сортировки
        int nTotal=8;         //количество элементов в массиве 

        /** Печать исходного массива */
        std::cout<< "Задание 2.2.1" << std::endl;
        std::cout<< "Первоначальный массив: ";
        for(int i=0; i<8; i++){std::cout<<nAr[i] << " ";}
        sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), swap_int, cmp_int);

        /** Печать результатов сортировки */
        std::cout<< std::endl;
        std::cout<< "Отсортированный массив: ";
        for(int i=0; i<8; i++){std::cout<<nAr[i] << " ";}

        std::cout<< std::endl;
        std::cout<< std::endl;
    }

    /**
     * Задание 2.2.2.
     *
     * По аналогии с заданием 2.2.1 напишите функцию swap_double и cmp_double,
     * и вызовите функцию sort для сортировки вещественных значений.
     */
    {
        double nAr[8]= {789.12, 56.12, -48.12, 52.12, 1863.12, -2.12, 7.12, 1.12};   //массив для сортировки
        int nTotal=8;         //количество элементов в массиве 

        /** Печать исходного массива */
        std::cout<< "Задание 2.2.2" << std::endl;
        std::cout<< "Первоначальный массив: ";
        for(int i=0; i<8; i++){std::cout<<nAr[i] << " ";}
        sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(double), swap_double, cmp_double);

        /** Печать результатов сортировки */
        std::cout<< std::endl;
        std::cout<< "Отсортированный массив: ";
        for(int i=0; i<8; i++){std::cout<<nAr[i] << " ";}

        std::cout<< std::endl;
        std::cout<< std::endl;
    }

    /**
     * Задание 2.2.3.
     *
     * По аналогии с 2.2.1 создайте вспомогательные функции - swap_str и
     * cmp_str и вызовите функцию sort для сортировки массива указателей на
     * строки.
     */

    {
        const char* arStr[] = {"QQQ", "SDF", "ABC"};
        int nTotal=3;         //количество элементов в массиве 

        /** Печать исходного массива */
        std::cout<< "Задание 2.2.3" << std::endl;
        std::cout<< "Первоначальный массив: ";
        for(int i=0; i<3; i++){std::cout<<arStr[i] << " ";}
        sort(reinterpret_cast<char*>(&arStr[0]), nTotal, sizeof(arStr[0]), swap_str, cmp_str);

        /** Печать результатов сортировки */
        std::cout<< std::endl;
        std::cout<< "Отсортированный массив: ";
        for(int i=0; i<3; i++){std::cout<<arStr[i] << " ";}

        std::cout<< std::endl;
        std::cout<< std::endl;
    }

    /**
     * Задание 2.3. Массивы указателей на функцию.
     *
     * Напишите функции для работы с массивом:
     *
     * 1. print_max - печатает максимальный элемент;
     * 2. print_min - печатает минимальный элемент;
     * 3. sort_asc - сортирует по возрастанию и выводит на печать;
     * 4. sort_desc - сортирует по убыванию и выводит на печать.
     *
     * У всех эти функций должна быть одинаковая сигнатура. Объявите, два
     * массива: массив указателей на функции 1-4 и массив указателей на строки
     * с описанием этих функций.
     *
     * Реализуйте меню для пользователя: выведите нумерованный список имен
     * функций (из второго массива), примите от пользователя номер функции,
     * после чего вызовите функцию для какого-нибудь массива.
     */
    std::cout<< "Задание 2.3" << std::endl;
    const int len_nAr23 = 8;
    int nAr23[len_nAr23]= {789, 56, -48, 52, 1863, -2, 7, 1};   //массив для сортировки
    
    void (*func_list23[len_nAr23])(int*, const int) = {print_max, print_min, sort_asc, sort_desc};

    std::cout<< "Первоначальный массив: ";
    for(int i=0; i<8; i++){std::cout<<nAr23[i] << " ";}
    std::cout<< std::endl;

    const char* opisanie[4] = {
        "1. print_max - печатает максимальный элемент",
        "2. print_min - печатает минимальный элемент",
        "3. sort_asc - сортирует по возрастанию и выводит на печать",
        "4. sort_desc - сортирует по убыванию и выводит на печать"
    };
    std::cout<< "Выберите функцию: " << std::endl;
    for(int i=0; i<4; i++){
            std::cout<<opisanie[i] << std::endl;
        }
    int vibor23;
    while(true){
        std::cout<< "Ваш выбор: ";
        if((std::cin>>vibor23) && 1 <= vibor23 && vibor23 <= 4){
            func_list23[vibor23-1](nAr23, len_nAr23);
            break;
        }
        else{
            std::cout<< "Ошибка ввода!" << std::endl;
            std::cin.clear(); // TODO: что делают эти фунции? зачем они?
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    }
    std::cout<< std::endl;
    std::cout<< std::endl;

    /**
     * Задание 2.4. Метод прямоугольников.
     *
     * Напишите функцию integrate, которая бы принимала:
     * 1. указатель на интегрируемую функцию, которая принимает double и
     *    возвращает double;
     * 2. нижнюю границу интегрирования (вещественное число);
     * 3. верхнюю границу интегрирования (вещественное число);
     * 4. количество отрезков, на которых будет вычисляться функция.
     *
     * Функция должна возвращать численное значение определенного интеграла,
     * полученного методом прямоугольников.
     *
     * Проверьте функцию на разных вещественных функциях (линейных, параболах,
     * exp, sin) и сравните полученные результаты с теоретическими.
     */
    std::cout<< "Задание 2.4" << std::endl;
    std::cout<< "Задайте через пробел границы интегрирования: ";
    double floor, ceiling;
    while(true){
        std::cin>> floor>> ceiling;
        if(floor>ceiling){
            std::cout<<"Диапазон задан некорректно, попробуйте ещё раз: ";
        }
        else{
            std::cout<< "Интеграл линейной: " << integrate(linear, floor, ceiling, (ceiling-floor)*8)<< std::endl; //(ceiling-floor)*8 просто решил так выбрать кол-во точек
            std::cout<< "Интеграл квадратичной: " << integrate(parabola, floor, ceiling, (ceiling-floor)*8)<< std::endl;
            std::cout<< "Интеграл экспоненты: " << integrate(exp, floor, ceiling, (ceiling-floor)*8)<< std::endl;
            std::cout<< "Интеграл синусоиды: " << integrate(sin, floor, ceiling, (ceiling-floor)*8)<< std::endl;
            break;
        }
    }
    std::cout<< std::endl;
    std::cout<< std::endl;
    /**
     * Задание 3. Структуры С.
     */

    /**
     * Задание 3.1. Структура Book.
     */

    /**
     * Задание 3.1.1.
     *
     * Объявите структуру Book, описывающую книгу (автор, заглавие, год
     * издания, цена, категория…).
     *
     * Подумайте: какого типа могут быть поля структуры.
     * Подсказка: объявление структуры рекомендуется выносить в заголовочный
     * файл.
     */

    /**
     * Задание 3.1.2.
     *
     * Создайте разными способами (глобальный, локальный, статический,
     * динамический) экземпляры (объекты) типа Book (без инициализации).
     *
     * Определите - сколько памяти отводит компилятор под каждый такой объект. 
     *
     * Как инициализируются (или не инициализируются) поля структуры?
     *
     * Подумайте: от чего зависит объем выделяемой памяти?
     */
    //book1 - глобальная до main
    Book book2;
    static Book book3;
    Book* book4 = new Book;
    std::cout<<"Задание 3.1.2"<<std::endl;
    std::cout<<"Размер глобальной структуры: "<< sizeof(book1)<<std::endl;
    std::cout<<"Размер локальной структуры: "<< sizeof(book2)<<std::endl;
    std::cout<<"Размер статической структуры: "<< sizeof(book3)<<std::endl;
    std::cout<<"Размер динамической структуры: "<< sizeof(book4)<<std::endl;
    std::cout<< std::endl;
    std::cout<< std::endl;
    /**
     * Задание 3.1.3. 
     *
     * Заполните поля созданных объектов.
     *
     * Замечание: если для хранения строки используется массив, необходимо
     * предусмотреть "защиту" от выхода за границы массива.
     */
    book1 = {"Pil'kin A. A.", "Outlines", 2017, 410, "poetry"};
    book2 = {"Danilevskii N. Y.", "Russia and Europe", 1869, 237, "geopolitics"};
    book3 = {"Leont'ev K. N.", "Byzantium and Slavism", 1876, 751, "sociology"};
    *book4 = {"Chaadaev P. Y.", "Philosophical letters", 1836, 474, "philosophy"};

    /**
     * Задание 3.1.4. 
     *
     * Напишите функцию, выводящую на экран реквизиты книги.
     *
     * Подумайте: как эффективнее передавать экземпляр Book в функцию.
     *
     * Для вывода на консоль используйте функцию стандартной библиотеки printf.
     */
    print_book(book1);
    std::cout<< std::endl;
    std::cout<< std::endl;
    delete book4;
    /**
     * Задание 3.1.5.
     *
     * Напишите функцию для формирования полей структуры. Для ввода используйте
     * функцию стандартной библиотеки scanf.
     *
     * Замечание: неплохо заложить в такую функцию возможность проверки
     * корректности введенного значения, например, год издания не может быть
     * меьше, чем... (год появления письменности), категорию ползователь должен
     * выбирать из существующих, цена не может быть отрицательной...
     *
     * Кроме этого необходимо проверить и ошибки другого рода: программа
     * ожидает число, а пользователь ввел случайно букву.
     */

    Book book5 = new_book();
    std::cout<< std::endl;
    print_book(book5);
    std::cout<< std::endl;
    std::cout<< std::endl;
    /**
     * Задание 3.2. Матричные операции.
     */

    /**
     * Задание 3.2.1. 
     *
     * Задайте структуру Matrix, которая будет преставлять вещественную матрицу
     * размера MxN из линейной алгебры.
     *
     * Это определение и связанные с ними функции определите в отдельной паре
     * файлов: matrix.h и matrix.cpp.
     */

    /**
     * Задание 3.2.2.
     *
     * Создайте набор базовых функций для работы с этой структурой:
     *
     * - void m_zero(Matrix *A, int m, int n) - инициализация матрицы размера m
     *   на n нулями;
     * - void m_id(Matrix *A, int n) - инициализация единичной матрицы n на n;
     * - void m_free(Matrix *A) - очистка памяти, используемой для матрицы;
     * - void m_copy(const Matrix *src, Matrix *dst) - копирование данных
     *   матрицы src в матрицу dst.
     * - int m_width(const Matrix *A) - ширина матрицы A;
     * - int m_height(const Matrix *A) - высота матрицы A;
     * - double m_get(const Matrix* A, int i, int j) - получение i,j-того
     *   элемента матрицы;
     * - void m_set(Matrix *A, int i, int j, double value) - установка i,j-того
     *   элемента матрицы.
     */

    Matrix matrA, matrC, matrB, matrD, matrH;

    m_zero(&matrA, 3, 5);
    std::cout<<"Нулевая матрица А:"<< std::endl;
    m_print(&matrA);
    std::cout<< "Имеет размеры: " << m_height(&matrA) << "×" << m_width(&matrA) << std::endl;
    std::cout<< std::endl;

    m_id(&matrC, 3);
    std::cout<<"Квадратная единичная матрица С:"<< std::endl;
    m_print(&matrC);
    std::cout<< std::endl;

    m_set(&matrA, 2, 2, 6);
    m_set(&matrA, 3, 4, 8);
    std::cout<<"Теперь в нулевой матрице А эл-т 2;2 равен "<< m_get(&matrA, 2, 2) << " а эл-т 3;4 равен "<< m_get(&matrA, 3, 4) << std::endl;
    m_print(&matrA);
    std::cout<< std::endl;

    m_zero(&matrB, 3, 5);
    m_copy(&matrA, &matrB);
    std::cout<<"Копия В изменённой нулевой матрицы А:"<< std::endl;
    m_print(&matrB);
    std::cout<< std::endl;
    
    /**
     * Задание 3.2.3.
     *
     * Реализуйте набор операций из линейной алгебры:
     *
     * - int m_add(Matrix *A, const Matrix *B) - если A и B одинакового
     *   размера, то прибавляет к A значения B и возвращает 0; иначе возвращает
     *   1.
     * - void m_neg(Matrix *A) - заменяет все элементы матрицы A на
     *   противоположные.
     * - int m_mult(const Matrix *A, const Matrix *B, Matrix *dst) - умножает
     *   матрицу A на матрицу B и сохраняет результат в dst. Если размеры
     *   матрицы не позволяют умножить матрицы, функция возвращает 1, иначе 0.
     */
    std::cout<<"A = A+B:" << std::endl;
    m_add(&matrA, &matrB);
    m_print(&matrA);
    std::cout<< std::endl;

    std::cout<<"Матрица С, в которой все эл-ты противололожные:" << std::endl;
    m_neg(&matrC);
    m_print(&matrC);
    std::cout<< std::endl;

    m_zero(&matrD, 3, 3);

    m_zero(&matrH, 5, 3);
    m_set(&matrH, 2, 2, 6);
    m_set(&matrH, 3, 3, 8);
    std::cout<<"Матрица H:" << std::endl;
    m_print(&matrH);
    std::cout<< std::endl;

    m_mult(&matrA, &matrH, &matrD);
    std::cout<<"D = A×H" << std::endl;
    m_print(&matrD);
    std::cout<< std::endl;

    /**
     * Задание 3.2.4.
     *
     * С помощью полученного функционала реализуйте матричное вычисление чисел
     * Фибоначчи. Делается это с помощью такой формулы:
     *
     * /  F[n]  \ = / 1  1 \ * / F[n-1] \
     * \ F[n-1] /   \ 1  0 /   \ F[n-2] /
     *
     * Задайте матрицу в центре и матрицу-вектор с двумя первыми числами
     * Фибоначчи: 1 и 0. Выполняйте эту формулу итеративно и выведите первые 40
     * чисел Фибоначчи.
     */
    long int* fib = new long int[41]();
    fibbonachi(fib, 41); //заполнит массив числами фиббоначи до n-го числа включительно
    for(int i=0; i<41; i++){
        std::cout<<i+1 <<" "<< fib[i] << " " <<std::endl;
    }

    delete[] fib;
    m_free(&matrA);
    m_free(&matrC);
    m_free(&matrB);
    m_free(&matrD);
    m_free(&matrH);
    return 0;
}
