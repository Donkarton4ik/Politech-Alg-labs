/**
 * Практическое занятие №3. Встроенные массивы. Динамическое выделение памяти.
 * Простейшие алгоритмы сортировки и поиска. Сложные указатели.
 */
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <string>

int main()
{
    /**
     * Задание 1. Встроенные массивы.
     */

    /**
     * Задание 1.1.
     *
     * Объявите трехмерный N*M*K массив и сформируйте значения
     * элементов, указанные на иллюстрации ниже, с помощью инициализации при
     * объявлении.
     *
     *                   |--------|     
     *                 / |3  3  3 |     
     *               |---------|3 |
     *             / | 2  2  2 |3 |
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__| 
     *            | 1  1  1 | /
     *            |_________|
     */
    int mas11 [3][3][3] {
        {{1, 1, 1}, 
         {1, 1, 1}, 
         {1, 1, 1}},

        {{2, 2, 2}, 
         {2, 2, 2}, 
         {2, 2, 2}},

        {{3, 3, 3}, 
         {3, 3, 3}, 
         {3, 3, 3}}
    };


    /**
     * Задание 1.2.
     *
     * Объявите неинициализированный массив и присвойте значения элементам с
     * помощью кода так, чтобы в итоге получился такой же массив, как в задании
     * 1.1.
     */
    int mas12[3][3][3];

    for(int i=0; i<3; i++){
        for(int j=0; j<3; j++){
            for(int k=0; k<3; k++){
                mas12[i][j][k] = i+1;
            }
        }
    }

    /**
     * Задание 1.3.
     *
     * Напишите код, с помощью которого можно найти сумму элементов массива,
     * полученного в задании 1.
     */
    int sum13 = 0;
    for(int i=0; i<3; i++){
        for(int j=0; j<3; j++){
            for(int k=0; k<3; k++){
                sum13 += i+1; //вместо записывания значения суммируем его
            }
        }
    }
    /**
     * Задание 1.4.
     *
     * Проинициализируйте массив при объявлении следующим образом:
     *
     *                   |--------|     
     *                 / |3  0  0 |     
     *               |---------|0 |
     *             / | 2  0  0 |0 |
     *            |---------|0 |__|
     *            | 1  0  0 |0 | /
     *            | 0  0  0 |__| 
     *            | 0  0  0 | /
     *            |_________|
     *
     * Как это можно сделать наиболее коротким (в смысле количества кода)
     * образом?
     */
    int mas14[][3][3] {{{1}}, 
                       {{2}}, 
                       {{3}},};

    /**
     * Задание 1.5. Инициализация массивов строковыми литералами.
     * 
     * Объявите и проинициализируйте строковыми литералами два массива:
     * двухмерный массив и массив указателей. Поясните разницу в использовании
     * элементов таких массивов.
     */
    char str15[3][10] = {"Lenin", "Marks", "Engels"};
    const char *ukstr15[3] = {"Lenin", "Marks", "Engels"};
    str15[0][1] = 'L';
    //ukstr15[0][1] = 'L'; //ошибка read-only location

    
    /**
     * Задание 2. Динамическое выделение памяти.
     */

    /**
     * Задание 2.1.
     *
     * Создайте динамический двухмерный массив с размерностями, вычисляемыми в
     * процессе выполнения программы - N*M, эти размерности можно сформировать
     * случайно в некотором диапазоне или ввести с консоли.
     *
     * Задайте значения элементов помощью генератора случайных чисел. 
     *
     * Найдите сумму элементов.
     *
     * Подсказка 1: для генерации случайных чисел используйте функцию
     * стандартной библиотеки - rand() (<cstdlib>).
     *
     * Подсказка 2: На самом деле те значения, которые создаются генератором
     * случайных чисел являются «псевдослучайными», то есть при двух
     * последовательных запусках приложения Вы получаете две одинаковые
     * последовательности значений.
     *
     * Для того чтобы генерируемые "случайные" значения были разными при каждом
     * запуске приложения используйте функции стандартной библиотеки srand()
     * (<cstdlib>) и time() (<ctime>).
     *
     * Функция srand() осуществляет «привязку» начала генерации к указанному в
     * качестве параметра значению.
     *
     * Функция time() задает эту точку отсчета, считывая текущее время.
     */
    srand(time(0));
    int m , n, sum21 = 0;
    std::cout<<"Задание 2.1"<<std::endl;
    std::cout << "Введите число строк N: ";
    std::cin >> n;
    std::cout << "Введите число колонок M: ";
    std::cin >> m;
    std::cout<< std::endl;

    int **mas21 = new int *[n];
    for (int i=0; i<n; i++){
        mas21[i] = new int[m];
    }

    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            mas21[i][j] = rand() % 100;
            sum21+=mas21[i][j];
        }
    }


    /**
     * Задание 2.2.
     *
     * В сформированном массиве отсортируйте каждую строку по убыванию
     * значений. Используйте сортировку "выбором".
     */
    std::cout<<"Задание 2.2"<<std::endl;
    for(int k=0; k < n; k++){
        for(int i=0; i < m-1; i++){
            int max=i;
            for(int j=i+1; j < m; j++){
                if (mas21[k][j] > mas21[k][max]){max = j;}
            }
            int vrem = mas21[k][i];
            mas21[k][i] = mas21[k][max];
            mas21[k][max] = vrem;
        }
    }

    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            std::cout<< mas21[i][j] << " ";
        }
        std::cout<< std::endl;
    }

    /**
     * Задание 2.3.
     *
     * Объявите одномерный массив размерностью N. 
     *
     * Сформируйте значение i-ого элемента одномерного массива  равным среднему
     * значению элементов i-ой строки двухмерного массива.
     */
    std::cout<<"Задание 2.3"<<std::endl;
    float *mas23 = new float[n];
    for(int i=0; i<n; i++){
        int ryad=0;
        for(int j=0; j<m; j++){
            ryad+=mas21[i][j];
        }
        mas23[i] = static_cast<float>(ryad)/m;
    }

    for(int i=0; i<n; i++){
        std::cout<< mas23[i] << " " << std::endl;
    }

    for (int i=0; i<n; i++){
        delete [] mas21[i];
    }
    delete [] mas21;
    delete [] mas23;

    /**
     * Задание 2.4. 
     *
     * Убедитесь, что вся выделенная память очищена.
     *
     * Чтобы убедиться в этом, скомпилируйте программу с включенной проверкой
     * утечек памяти - с ключом `-fsanitize=address`:
     *
     * `gcc <ваши обычные флаги> -fsanitize=address lab3.cpp`
     *
     * Если после выполнении программы выдаются сообщения об утечках, это
     * означает, что где-то не удалена выделенная память.
     */




    /**
     * Задание 3.
     */

    /**
     * Задание 3.1. Онлайн-упорядочивание.
     *
     * Напишите фрагмент кода, который вводит N целых чисел с помощью потока
     * ввода в объявленный Вами встроенный одномерный массив, каждый раз
     * упорядочивая полученное значение по возрастанию.
     *
     * Дайте оценку количества сравнений и перестановок при вводе всех чисел
     * относительно N.
     *
     * Постарайтесь, чтобы и сравнений, и перестановок было не больше, чем
     * k*N^2, где k - некоторое число.
     */
    /*std::cout<<"Задание 3.1"<<std::endl;
    std::cout<< "Введите длину N массива: ";
    std::cin>> n; //n до этого объявлена как int
    std::cout<< std::endl;
    if (n>0){
        int*  mas31 = new int[n];
        //int defoltich = mas31[0]; // TODO: что если значения будут разные? это UB
        std::cout<< "Введите элементы массива: " << std::endl;
        for(int i=0; i < n-1; i++){
            std::cout<< i+1 << ") ";
            std::cin>> mas31[i];

            for(int j=0; j < n-1; j++){ //bubble
                bool flag = false;
                for(int k=0; k < n-j-1; k++){
                    if(mas31[k] > mas31[k+1]){
                        int vrem = mas31[k];
                        mas31[k] = mas31[k+1];
                        mas31[k+1] = vrem;
                        flag = true;
                    }
                }
                if (flag==false){break;}
            }


            for(int j=0; j < n; j++){ //вывов массива в каждой итерации
                if(mas31[j]!=defoltich){
                    std::cout<< mas31[j] << " ";
                }
            }
            for(int j=0; j < n; j++){
                std::cout<< mas31[j] << " ";
            }
            std::cout<< std::endl;
        }
        delete [] mas31;
    }
    else{std::cout<< "Массив не может состоять меньше, чем из 1 элемента"<< std::endl;}*/

    std::cout<<"Задание 3.1"<<std::endl;
    std::cout << "Введите длину N массива: ";
    std::cin>> n; //n до этого объявлена как int

    if(n>0){
        int* mas31 = new int[n]; 
        int current = 0; //индекс отсортированной части массива

        std::cout<< "Введите числа: " << std::endl;

        for(int i = 0; i < n; i++){
            int value, index;
            std::cout<< i+1 << ") ";
            std::cin>> value;
            
            if(current==0){
                mas31[0] = value;
            }
            else{
                index=current; //т. е. поставим последним, если value больше любого числа в массиве
                for(int j=0; j<=current; j++){
                    if(mas31[j]>value){
                        index=j; //индекс на котором должно стоять новое value
                        break;
                    }
                }
                
                for(int j=current; j>index; j--){//сдвигаем вправо на 1 эл-т
                    mas31[j] = mas31[j-1];
                }
                mas31[index]=value; //вставляем в индекс
            }
            std::cout<< "Массив после вставки: ";
            for(int k=0; k<=current; k++){
                std::cout<< mas31[k] << " ";
            }
            std::cout<< std::endl;
            current++;
        }
        

        delete[] mas31; // Освобождаем память
    } 
    else{
        std::cout<< "Длина массива должна быть положительной!" << std::endl;
    }
    
    /**
     * Задание 3.2. Простой поиск.
     *
     * Модифицируйте предыдущее задание следующим образом:очередное значение
     * вводится в массив только при условии, что там еще такого нет (то есть
     * дубли игнорируются).
     */
    std::cout<<"Задание 3.2"<<std::endl;
    std::cout<< "Введите длину N массива: ";
    std::cin>> n; //n до этого объявлена как int
    std::cout<< std::endl;
    if (n>0){
        int*  mas32 = new int[n];
        int defoltich = mas32[0];
        std::cout<< "Введите элементы массива: " << std::endl;
        for(int i=0; i < n; i++){
            int vvod;
            bool povtor;
            povtor = false;
            std::cout<< i+1 << ") ";
            std::cin>> vvod;
            for(int j=0; j < n; j++){   // поиск повтора
                if(vvod == mas32[j]){
                    povtor=true;
                    break;
                }
            } 

            if(povtor){
                while(povtor){
                    std::cout<< "Элементы не могут повторяться!" << std::endl;
                    std::cout<< i+1 << ") ";
                    std::cin>> vvod;
                    bool ispravil=true;
                    for(int j=0; j < n; j++){   // поиск повтора
                        if(vvod == mas32[j]){
                            ispravil=false;
                            break;
                        }
                    }
                    if(ispravil){povtor=false;}
                }
            }

            mas32[0] = vvod;
            for(int j=0; j < n-1; j++){    //bubble
                bool flag = false;
                for(int k=0; k < n-j-1; k++){
                    if(mas32[k] > mas32[k+1]){
                        int vrem = mas32[k];
                        mas32[k] = mas32[k+1];
                        mas32[k+1] = vrem;
                        flag = true;
                    }
                }
                if (flag==false){break;}
            }

            for(int j=0; j < n; j++){ //вывов массива в каждой итерации
                if(mas32[j]!=defoltich){
                    std::cout<< mas32[j] << " ";
                }
            }
            std::cout<< std::endl;

        }
        delete [] mas32;
    }
    else{std::cout<< "Массив не может состоять меньше, чем из 1 элемента"<< std::endl;}
     
    /**
     * Задание 4. Сортировка строк.
     *
     * С помощью данной заготовки напишите программу, которая:
     *
     * 1. вводит строки с клавиатуры с помощью cin>>... в объявленный Вами
     *    двухмерный встроенный массив 5*80 элементов типа char; признаком конца
     *    ввода является символ * (то есть строка - "*") или заполнение массива
     *    (больше свободных строк нет);
     * 2. сортирует строки в алфовитном порядке и выводит на экран.
     *
     * Пояснение: крайне не рекомендуется для сортировки сложных объектов
     * физически перемещать их в памяти. Намного эффективнее завести массив
     * указателей на соответствующие строки и перемещать только указатели.
     *
     * Подсказка: для лексиграфического сравнения строк пользуйтесь функцией
     * стандартной библиотеки strcmp(...), заголовочный файл <cstring>.
     */

    {
        /** Определите необходимые значения как константы */
        std::cout<<"Задание 4"<<std::endl;
        const char* STOP_STRING  =  "*";  //признак "прекратить ввод"
        const int M  =  80; //максимальный размер одной строки
        const int N  =  10; //максимальное количество строк в массиве
        /** 
         * Объявите двухмерный массив с именем cBuffer типа char и размерностью
         * N*M.
         */
        char cBuffer[N][M];
        /**
         * Объявите массив (с именем cPointers) указателей на строки
         * размерностью N.
         */
        char* cPointers[N];
        /** 
         * Цикл ввода строк:
         * 1. выведите приглашение для ввода; 
         * 2. пока не введена строка STOP_STRING или не заполнен весь массив; 
         */

        {
            std::cout<< "Введите до 10 строк длиной до 80 символов (досрочное завершение ввода '*')" << std::endl;
            int real_kolvo = 0;
            for(int i=0; i<N; i++){
                std::cout<< i+1 << ") ";
                /** ввод строки в массив cBuffer: */
                std::cin>> cBuffer[i];
                /** если введена строка - признак окончания, то выйти из цикла */
                if(strcmp(cBuffer[i], STOP_STRING) == 0){break;}

                real_kolvo++;
                /** Присвойте элементу массива cPointers с индексом nIndex */
                /** указатель на строку с номером nIndex в массиве cBuffer */
                cPointers[i] = cBuffer[i];
            }
            /** Выдать диагностику о том, что прием строк завершен.*/
            std::cout<< "Считывание строк завершено" << std::endl;
            /**
            * Теперь сортируем строки.
            *
            * Необходимо использовать сортировку строк по методу "всплывающего
            * пузырька" в порядке возрастания. 
            *
            * На каждой итерации - промежуточная печать отсортированных строк.
            */
            std::cout<<"СоРтИрОвОчКа:" << std::endl;
            for(int i=0; i < real_kolvo-1; i++){
                bool flag = false;
                for(int j=0; j < real_kolvo-i-1; j++){
                    if(strcmp(cPointers[j], cPointers[j+1])>0){
                        char* vrem = cPointers[j];
                        cPointers[j] = cPointers[j+1];
                        cPointers[j+1] = vrem;
                        flag = true;


                        for(int k=0; k < real_kolvo; k++){
                        std::cout<< cPointers[k] << " ";
                        }
                        std::cout<< std::endl;
                    }
                }
                if(flag==false){break;}
            }

            std::cout<< "Массив после сортировки: ";
            for(int k=0; k < real_kolvo; k++){
                std::cout<< cPointers[k] << " ";
                }
            std::cout<< std::endl;
            std::cout<< std::endl;
        }
    }

/*
    /**
     * Задание 5. Динамические строки.
     *
     * Реализуйте задание №4, используя не встроенные, а динамические массивы
     * (массив?). Так как строки могут быть разной длины, эффективным решением
     * было бы отводить под каждую строку ровно столько байтов, сколько
     * требуется для ее хранения.
     *
     * Реализуйте это задание так, чтобы пользователь мог ввести строку любой
     * длины (которая помещается в память компьютера - читайте: неограниченной
     * длины).
     *
     * При этом необходимые параметры (количество строк) сформируйте с помощью
     * потока ввода.
     */
    
    
    {
        int nStringNumber;
        std::cout<<"Задание 5"<<std::endl;
        std::cout<<"Введите число строк для сортировки: ";
        std::cin>> nStringNumber;
        if(nStringNumber < 1){std::cout<<"Массив не может состоять меньше, чем из 1 элемента!" << std::endl;}
        else{
            char* ukstr5[nStringNumber]; //указатели
            char **mas5 = new char*[nStringNumber]; //строки
            
            for(int i=0; i<nStringNumber; i++){ //цикл ввода строк: 
                char vvod5[1000000];
                std::cout<< i+1 << ") ";
                std::cin>> vvod5;

                int simvolVV=0;
                while(vvod5[simvolVV] != '\0'){  //длина вводимой строки
                    simvolVV++;
                }
                mas5[i] = new char[simvolVV + 1];
                for(int j=0; j < (simvolVV+1); j++){ //записывание вводимой строки
                    mas5[i][j] = vvod5[j];
                }
                ukstr5[i] = mas5[i];
            }
             
            std::cout<<"СоРтИрОвОчКа:" << std::endl;
            for(int i=0; i < nStringNumber-1; i++){
                bool flag = false;
                for(int j=0; j < nStringNumber-i-1; j++){
                    if(strcmp(ukstr5[j], ukstr5[j+1])>0){
                        const char* vrem = ukstr5[j];
                        ukstr5[j] = ukstr5[j+1];
                        ukstr5[j+1] = const_cast<char*>(vrem);
                        flag = true;


                        for(int k=0; k < nStringNumber; k++){
                        std::cout<< ukstr5[k] << " ";
                        }
                        std::cout<< std::endl;
                    }
                }
                if(flag==false){break;}
            }

            std::cout<< "Массив после сортировки: ";
            for(int k=0; k < nStringNumber; k++){
                std::cout<< ukstr5[k] << " ";
                }

            for (int i=0; i<nStringNumber; i++){
                delete [] mas5[i];
            }        
            delete [] mas5;
        }

    }
    std::cout<< std::endl;
    std::cout<< std::endl;

    /** 
     * Задание 6. Работа со строками.
     *
     * Реализуйте следующую программу. Пользователь вводит строку (любого
     * размера), после чего пользователю выводится на консоль следующее
     * изображение, где его ввод помещен в "speech bubble":
     *
     *  _____________________________________
     * / Here user input is shown. This line \ 
     * \ must be at most 40 characters long. /
     *  ------------------------------------
     *     \
     *      \
     *        /\_/\  (
     *       ( ^.^ ) _)
     *         \"/  (
     *       ( | | )
     *      (__d b__)
     *
     *  При этом длина строки в "облачке" должна быть не более 40 символов, при
     *  этом слова должны переноситься аккуратно. Это означет, что не должно
     *  быть переносов в центре слова (если только это слово не больше 40
     *  символов).
     *
     *  Дизайн облачка и ASCII-арт допустимо поменять по усмотрению.
     *
     *  Подсказка: обратите внимание на конкатенацию строковых литералов в
     *  языке С, это позволит задавать подобные рисунки так, чтобы они
     *  адекватно выглядели в коде.
     */
    std::cin.ignore();    //без этого кота скипает
    std::cout << "Задание 6" << std::endl;
    std::cout << "Введите текст, который вам повторит кошак: ";

    int total_i = 0, vivod_i = -1; // глобальный счётчик итераций + счётчик строк на вывод

    char ch; // Считываемый символ
    int len_message = 0;
    char *vvod_cat = new char[len_message]; //вводимая строка

    while(std::cin.get(ch) && ch != '\n'){
        char *vrem = new char[len_message + 1];
        std::copy(vvod_cat, vvod_cat + len_message, vrem);
        vrem[len_message] = ch;
        len_message++;
        delete[] vvod_cat;
        vvod_cat = vrem;
    }

    char **vivod = new char*[vivod_i+1]; // массив строк на вывод

    while(total_i < len_message){     //ЗАПОЛНЕНИЕ ВЫВОДА
        vivod_i++;
        char **vrem_vivod = new char*[vivod_i + 1];
        for(int i = 0; i < vivod_i; i++){
            vrem_vivod[i] = vivod[i];
        }
        vrem_vivod[vivod_i] = new char[41](); // инициализируем новую строку нулями
        delete[] vivod;
        vivod = vrem_vivod;

        int nomer_bukvi = 0;
        if(total_i + 39 >= len_message){  // если оставшаяся часть строки короче 40 символов
            for(int i = total_i; i < len_message; i++){
                vivod[vivod_i][nomer_bukvi++] = vvod_cat[i];
            }
            while(nomer_bukvi < 40){
                vivod[vivod_i][nomer_bukvi++] = ' ';
            }
            break;
        }

        int probel = 0;
        for(int i = 0; i < 40; i++){
            if (vvod_cat[total_i] == ' '){probel++;}
            total_i++;
        }

        if((probel > 0) && (vvod_cat[total_i] != ' ') && (vvod_cat[total_i + 1] != ' ')){
            int local_probel = 0;
            for(int j = total_i - 40; j < total_i; j++){
                if(vvod_cat[j] == ' '){local_probel++;}
                if(local_probel == probel){
                    total_i = j + 1;
                    break;
                }
                vivod[vivod_i][nomer_bukvi++] = vvod_cat[j];
            }
            while(nomer_bukvi < 40){
                vivod[vivod_i][nomer_bukvi++] = ' ';
            }
        }
        
        else{
            for(int j = total_i - 40; j < total_i; j++){
                vivod[vivod_i][nomer_bukvi++] = vvod_cat[j];
            }
        }
    }

    std::cout << " __________________________________________" << std::endl;
    for(int i = 0; i <= vivod_i; i++){
        std::cout << "| " << vivod[i] << " |" << std::endl;
    }
    std::cout << " ------------------------------------------" << std::endl;
    std::cout << "    \\             " << std::endl;
    std::cout << "     \\            " << std::endl;
    std::cout << "       /\\_/\\  (  " << std::endl;
    std::cout << "      ( ^.^ ) _)   " << std::endl;
    std::cout << "        \\\"/  (   " << std::endl;
    std::cout << "      ( | | )      " << std::endl;
    std::cout << "     (__d b__)     " << std::endl;

    delete[] vvod_cat;
    for(int i = 0; i <= vivod_i; i++){
        delete[] vivod[i];
    }
    delete[] vivod;

    /** 
     * Задание 7. Сложные указатели.
     *
     * Объявление и использование указателей на многомерные массивы.
     * Проинициализируйте трехмерный массив double dArray[4][3][3] так, как
     * показано на рисунке и напишите фрагмент кода, который меняет местами
     * значения элементов четных и нечетных слоев:
     *
     *  было:                |--------|     
     *                     / |4  4  4 |     
     *                   |--------| 4 | 
     *                 / |3  3  3 | 4 | 
     *               |---------|3 |   |
     *             / | 2  2  2 |3 | /
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__| 
     *            | 1  1  1 | /
     *            |_________|
     *
     *  стало:               |--------|     
     *                     / |3  3  3 |     
     *                   |--------| 3 | 
     *                 / |4  4  4 | 3 | 
     *               |---------|4 |   |
     *             / | 1  1  1 |4 | /
     *            |---------|1 |__|
     *            | 2  2  2 |1 | /
     *            | 2  2  2 |__| 
     *            | 2  2  2 | /
     *            |_________|
     */

    {
        double dArray[4][3][3] {
            {{1, 1, 1}, 
             {1, 1, 1}, 
             {1, 1, 1}},

            {{2, 2, 2},
             {2, 2, 2},
             {2, 2, 2}}, 

            {{3, 3, 3},
             {3, 3, 3},
             {3, 3, 3}},

            {{4, 4, 4},
             {4, 4, 4},
             {4, 4, 4}}
        };

        for(int i=0; i<4; i+=2){
            /** 
             * Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА
             * РАВЕНСТВА!!! 
             */
            // ... =  dArray[i];
            // ... =  dArray[i+1];

            double (*uk7_0_odd)[3] =  dArray[i];
            double (*uk7_0_even)[3] =  dArray[i+1];
            /** переставляем местами элементы i-того и i+1-ого слоев */
            for(int j=0; j<3; j++){
                for(int k=0; k<3; k++){
                    double vrem7_0 = uk7_0_odd[j][k];
                    uk7_0_odd[j][k] = uk7_0_even[j][k];
                    uk7_0_even[j][k] = vrem7_0;
                }
            }

        }

        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout << "Задание №7.0" << std::endl;
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    std::cout << dArray[i][j][k] << " ";
                }
                std::cout << std::endl;
            } 
        }
    }
    std::cout<< std::endl;
    std::cout<< std::endl;
    
    /**
     * Задание 7.
     */

    /**
     * Задание 7.1.
     *
     * Объявите двухмерный встроенный массив элементов типа char.
     *
     * Сформируйте значения элементов массива с помощью генератора случайных
     * чисел таким образом, чтобы в массиве были только символы '*' и '_'.
     *
     * В каждой строке "сдвиньте звездочки" в начало строки, например:
     * было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
     * стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
     * и распечатайте массив по строкам.
     *
     * При этом оцените количество операций, которое требуется для обработки
     * одной строки относительно длины этой строки.
     *
     * Постарайтесь решить эту задачу так, чтобы требовалось не более k*N 
     * операций, где N - длина строки, k - некое фиксированное число.
     */
    
    {
        std::cout<< "Задание 7.1" << std::endl;
        int M = 8, N = 10;
        srand(time(0));
        char mas71[M][N];
        std::cout << "Первоначальный массив:" << std::endl;
        for(int i=0; i<M; i++){
            for(int j=0; j<N; j++){
                if(rand() % 2 == 0 ) {mas71[i][j] = '*';}
                else{mas71[i][j] = '_';}
                std::cout << mas71[i][j] << " ";
            }
            std::cout<< std::endl;
        }
        
        for (int i = 0; i < M; i++) {
            int sdvig = 0;
            char (*uk71)[N] = mas71;

            for (int j = 0; j < N; j++) {
                if (uk71[i][j] == '*') {
                    std::swap(uk71[i][sdvig], uk71[i][j]);
                    if (sdvig+1 <= N){sdvig++;} //без этого санитайзер говорит о выходе за рамки
                }
            }
        }

        std::cout << "ОтСоРтИрОвАнНыЙ массив:" << std::endl;
        for(int i=0; i<M; i++){
            for(int j=0; j<N; j++){
                std::cout << mas71[i][j] << " ";
            }
            std::cout<< std::endl;
        }
        std::cout<< std::endl;
        std::cout<< std::endl;
    }

    /**
     * Задание 7.2.
     *
     * Модифицируйте предыдущее задание следующим способом: После заполнения
     * массива с помощью генератора случайных чисел "сдвиньте" звездочки по
     * столбцам вниз и распечатайте результат.
     */

    {
        std::cout<< "Задание 7.2" << std::endl;
        int M = 8, N = 10;
        srand(time(0));
        char mas72[M][N];
        std::cout << "Первоначальный массив:" << std::endl;
        for(int i=0; i<M; i++){
            for(int j=0; j<N; j++){
                if(rand() % 2 == 0 ) {mas72[i][j] = '*';}
                else{mas72[i][j] = '_';}
                std::cout << mas72[i][j] << " ";
            }
            std::cout<< std::endl;
        }
        
        for (int i = 0; i < N; i++) {
            int sdvig = 0;
            char (*uk72)[N] = mas72;

            for (int j = 0; j < M; j++) {
                if (uk72[j][i] == '_') {
                    std::swap(uk72[sdvig][i], uk72[j][i]);
                    if (sdvig+1 <= M){sdvig++;} //без этого санитайзер говорит о выходе за рамки
                }
            }
        }

        std::cout << "ОтСоРтИрОвАнНыЙ массив:" << std::endl;
        for(int i=0; i<M; i++){
            for(int j=0; j<N; j++){
                std::cout << mas72[i][j] << " ";
            }
            std::cout<< std::endl;
        }
        std::cout<< std::endl;
        std::cout<< std::endl;
    }

    return 0;
}

// TODO: не собирается :(

/*
lab3.cpp:461:5: warning: '/*' within block comment [-Wcomment]
    /**
    ^
lab3.cpp:788:20: error: cannot initialize a variable of type 'char (*)[N]' with an lvalue of type 'char[M][N]'
            char (*uk71)[N] = mas71;
                   ^          ~~~~~
lab3.cpp:834:20: error: cannot initialize a variable of type 'char (*)[N]' with an lvalue of type 'char[M][N]'
            char (*uk72)[N] = mas72;
                   ^          ~~~~~
1 warning and 2 errors generated.
*/
