/**
 * Лабораторная работа №1. Классы и объекты в языке C++: конструкторы,
 * деструкторы, поля и методы. Различные способы применения классов. Сборка
 * проекта и автоматические тесты.
 *
 * Лабораторные работы 1-3 в этом семестре построены в виде программы на языке
 * C++, в функции main этой программы в комментариях написаны задания, которые
 * необходимо выполнить.
 *
 * Для выполнения задания необходимо выполнить следующее.
 *
 * 1. Написать код на языке C++, реализующий требования в задании или написать
 *    в комментариях ответ на поставленный вопрос. Все задания должны быть
 *    реализованы в рамках одной программы, которая должна собираться и работать
 *    без ошибок, если в задании явно не указано обратное.
 * 2. В написанной программе не должно быть ошибок в работе с памятью: утечек
 *    памяти, чтение или запись вне выделенной памяти, использование памяти
 *    после освобождения. Для этого строго рекомендуется использовать
 *    инструментальные средства, такие как AddressSanitizer, Valgrind, leaks, VLD и
 *    пр.
 * 3. В рамках работ этого семестра мы НЕ используем контейнеры стандартной
 *    библиотеки C++: string, vector, list, map, set, shared_ptr, unique_ptr и
 *    пр. Целью работ в том числе является обучение работе с памятью с помощью
 *    объектов. Задания должны быть выполнены без использования этих или
 *    аналогичных готовых классов.
 *
 * Для этих работ указания будут приведены для следующих инструментов
 * разработки:
 *
 * - компилятор g++;
 * - отладчик gdb;
 * - командная строка bash;
 * - система сборки GNU Make;
 * - библиотека AddressSanitizer для обнаружения утечек памяти.
 *
 * Вы можете использовать другие инструменты (zsh, clang, lldb, CMake, VS и
 * пр.), если они позволяют выполнить задания в полном объёме.
 *
 * Перед выполнением работ настоятельно рекомендуется выполнить работы первого
 * семестра, чтобы познакомиться с базовыми конструкциями языка C и с
 * особенностями работы с памятью в языке С, а также получить опыт работы с
 * компилятором и отладчиком.
 */

#include <iostream>
#include "rect.hpp"
#include "barrel.hpp"
#include"matrix.hpp"
//#include"my_string.hpp"
#include"text_wrapper.hpp"

int main()
{
    /**
     * Задание 1. Классы. Объявление класса, создание экземпляров класса. Явные
     * и неявные конструкторы и деструкторы. Методы класса и их вызов.
     */

    /**
     * Задание 1.1. Объявление класса.
     *
     * Создайте новый класс с именем `Rect`. Этот класс должен представлять
     * прямоугольник на двумерной координатной плоскости, стороны которого
     * параллельны осям координат. Такие прямоугольники особенно часто
     * встречаются при разработке графических приложений - любое окно программы
     * является именно таким прямоугольником.
     *
     * Обычно классы объявляют в отдельной паре файлов: в заголовочном файле
     * `rect.hpp` объявлют класс и вспомогательные определения (константы,
     * enum'ы и прочее), в файле `rect.cpp` определяют методы класса.
     *
     * Создайте файлы `rect.hpp` и `rect.cpp`, определите в файле `rect.hpp` 
     * класс `Rect` у которого будет 4 целочисленных поля, имеющих смысл 
     * координат левой, правой, верхней и нижней границы прямоугольника.
     * Пока что не объявляйте явно никаких конструкторов или деструкторов.
     *
     * Подключите файл `rect.hpp` к этому файлу директивой `include`.
     */

    /**
     * Задание 1.2. Неявные (implicit) конструкторы и деструкторы.
     *
     * Раскоментируйте следующий блок кода. С помощью отладчика посмотрите,
     * как были инициализированы поля класса.
     *
     * Объясните, какой код будет вызываться для объекта при выполнении
     * следующего блока, кто определил этот код, что такой код делает в этом
     * случае и в общем случае.
     */

    {
        //Rect rect; //поля не инициализируются, они будут содержать мусорные значения
    }

    /**
     * Задание 1.3. Явно определенные конструкторы. Конструктор по умолчанию.
     *
     * Объявите в файле `rect.hpp` конструктор для класса `Rect`, который бы
     * принимал бы 4 координаты сторон прямоугольника (соответственно полям).
     *
     * Объясните ошибку компиляции, которая произошла после добавления
     * конструктора.
     *
     * Добавьте конструктор по умолчанию, который заполняет все координаты
     * нулями.
     */
    
    {
        std::cout<< "Задание 1.3\n";
        Rect rect(1, 2, 3, 4); // когда явно добавили конструктор с параметрами, компилятор перестал автоматически генерировать конструктор по умолчанию
    }

    /**
     * Задание 1.4. Конструктор копирования.
     *
     * Раскоментируйте блок кода ниже. Какие конструкторы вызываются в коде
     * этого блока? Кто определил эти конструкторы? Что они делают в этом случае 
     * и в общем случае?
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 1.4\n";
        Rect rect1(1, 2, 3, 4); //вызывается конструктор с параметрами
        Rect rect2 = rect1; //вызывается неявный конструктор копирования
        Rect rect3(rect1); //вызывается тот же неявный конструктор копирования
    }

    /**
     * Задание 1.5. Деструктор.
     *
     * Что такое деструктор? Когда он вызывается? Есть ли деструктор в вашем
     * классе `Rect`? Что делает такой деструктор в вашем случае и в общем
     * случае?
     *
     * Определите в классе `Rect` деструктор, в котором поставьте отладочную
     * печать. Пронаблюдайте и зафиксируйте в предыдущих заданиях, когда
     * вызывается деструктор.
     */

    /*
    Деструктор — это метод класса, который автоматически вызывается при удалении класса.
    Явного деструктора в классе rect нет, поэтому компилятор автоматически генерирует деструктор.
    В нашем случае деструктор ничего не делает. 
    В общем случае автоматически сгенерированный деструктор вызывает деструкторы для членов класса(если они являются объектами других классов)
    и базовых классов(еслт, например, rect был бы производным классом от какого-нибудь base_rect).
    */

    /**
     * Задание 1.6. Когда вызываются конструкторы и деструкторы?
     *
     * Определите явно конструктор копирования в классе `Rect`, который делал
     * бы то же, что и конструктор копирования, определенный неявно.
     *
     * Добавьте во все конструкторы отладочную печать, которая бы печатала, какой 
     * конструктор вызван и адрес объекта через указатель `this`.
     *
     * Проследите, когда в следующем блоке кода вызываются конструкторы и
     * деструкторы для каждого объекта. Отметьте в комментариях места в коде,
     * где это происходит. Подсчитайте общее количество вызовов конструкторов и
     * деструкторов и объясните это количество.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 1.6\n";

        Rect r1; //конструктор по умолчанию
        Rect *pR = new Rect(1,2,1,2); //конструктор с параметрами   
        {
            Rect r2(r1); //конструктор копирования
            Rect arRect[2]; //конструктор по умолчанию х2, т.к. массив из 2 объектов
            for(int i = 0; i < 3; i++)
            {
                static Rect r3 (i,i,i,i) ; //конструктор с параметрами, но вызывается лишь на первой итерации цикла из-за static
                Rect r4(*pR); //конструктор копирования
                Rect r5(i,i,i,i); //конструктор с параметрами 
            } //деструктор у объекта r4 и r5 (r3 не уничтожается из-за static)
        } // деструктор у r2 и объектов массива (х2)
        delete pR;  //деструктор динамического pR
    } //деструктор r1
    //static r3 удалится только после завершения программы

    /**
     * Задание 1.7. Публичные и приватные поля класса.
     *
     * Сделайте все поля вашего класса приватными. Попробуйте в блоке кода ниже
     * обратиться к полю напрямую. Объясните ошибку компиляции.
     */

    /*{
        Rect r1;
        std::cout << r1.left << std::endl; //все поля private => к ним можно обращаться только внутри полей и методов класса
    }*/

    /**
     * Задание 1.8. Инкапсуляция. Методы для доступа к объектам класса.
     *
     * Принципы объектно-ориентированного программирования предписывают
     * разделять ответственности разработчиков и пользователей определенной
     * функциональности. Разработчик глубоко разбирается в том, как работает
     * эта функциональность, а пользователь освобожден от этой необходимости и
     * пользуется только публичным интерфейсом, за который несет ответственность
     * разработчик. При этом пользователь рассчитывает *только* на публичный
     * интерфейс, а не на внутреннюю реализацию, что позволяет разработчику
     * поддерживать совместимость только интерфейса, а внутреннюю реализацию
     * менять по своему усмотрению.
     *
     * Например, хранение вещей в доме X организуется мамой, она указывает, где
     * найти определенную вещь и куда ее надо потом положить, и никто кроме нее
     * не знает, где что лежит. Если все члены семьи будут брать и класть вещи,
     * как им хочется, будет хаос. Чтобы его не было, нужно либо всем знать,
     * как именно мама раскладывает вещи (по какой логике), либо проводить все
     * операции через маму. Первый вариант запрещает маме менять логику
     * хранения по своему усмотрению - нужно будет переучивать всех, второй же
     * менее гибкий и более бюрократичный. Какой из них верный - зависит от
     * ситуации, и больше всего это зависит от количества людей в системе. Если
     * с мамой живет только папа, то и первый вариант вполне подходит, а если
     * еще и двузначное количество детей и тетушек, то, вероятно, некая форма
     * бюрократии будет необходима.
     *
     * В этом примере функциональностью является хранение вещей, а публичным
     * интерфейсом - мама. В C++ же функциональность оформляется в виде
     * классов, а публичный интерфейс в виде методов в секции `public`.
     *
     * В этом примере и далее мы будем *предполагать*, что "бюрократичный"
     * вариант является верным и будем реализовать именно его - в первую
     * очередь в учебных целях, - потому что реализовать "первый" вариант
     * всегда легче. Мы будем *все* поля класса помещать в секцию `private`, а
     * доступ к ним будем давать через методы.
     *
     * Итак, добавьте в ваш класс публичные методы `get_left`, `get_right`,
     * `get_top` и `get_bottom`, которые будут возвращать значения координат
     * левой, правой, верхней и нижней стороны прямоугольника соответственно.
     *
     * Добавьте метод `set_all(int left, int right, int top, int bottom)`,
     * который устанавливал значения соответствующих полей.
     *
     * Продемонстрируйте работу этих методов ниже.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 1.8\n";

        Rect r;
        std::cout << r.get_left() << "; " << r.get_right() << '\n';
        r.set_all(1, 2, 3, 4);
        std::cout << r.get_top() << "; " << r.get_bottom() << '\n';
    }

    /**
     * В литературе, особенно английской, методы часто называют
     * функциями-членами (member-functions), и этот термин предпочтительно
     * использовать в контексте именно C++, а не других объектно-ориентированных
     * языков (Java, Python и др.).
     *
     * Напишите в комментариях, чем функция-член отличается от обычной функции.
     */
    /*
    1) Функция-член принадлежит классу и вызывается через объект. Обычная ф-ция вызывается напрямую
    2) Функция-член имеет доступ к методам и полям private и protected класса, когда обычная ф-ция имеет доступ лишь к public методам и полям 
    3) Внутри функция-члена можно использовать указатель this
    */

    /**
     * Задание 1.9. Перегрузка функций и методов. Значение параметров по
     * умолчанию.
     *
     * Добавьте методы в класс `Rect`:
     * - `void inflate(int amount)` - отодвигает каждую из сторон от центра
     *   прямоугольника на величину `amount`;
     * - `void inflate(int dw, int dh)` - отодвигает верхнюю и нижнюю сторону на `dh`,
     *   а левую и правую - на `dw`;
     * - `void inflate(int d_left, int d_right, int d_top, int d_bottom)` - аналогично,
     *   но для каждой стороны отдельно.
     *
     * Реализуйте метод `void move( ? )` со значениями параметров по умолчанию,
     * который осуществляет параллельный перенос по следующей логике: 
     * - `rect.move(1, 2)` перемещает прямоугольник на 1 по оси Х и на 2 по оси Y;
     * - `rect.move(1)` перемещает прямоугольник на 1 по оси X.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 1.9\n";
 
        Rect r;
        r.set_all(1, 2, 4, 3);
        print_rect(r);
        r.inflate(1);
        print_rect(r);
        r.inflate(1, 1);
        print_rect(r);
        r.inflate(0, 1, 0, 1);
        print_rect(r);
        r.move(1);
        print_rect(r);
        r.move(1, 1);
        print_rect(r);
    }

    /**
     * Задание 1.10. Передача объектов в функции и из функции.
     *
     * Создайте функцию `Rect bounding_rect(Rect r1, Rect r2)`, которая будет
     * возвращать наименьший прямоугольник, в котором находятся прямоугольники
     * `r1` и `r2`.
     *
     * Создайте функцию `void print_rect(Rect &r)`, которая будет печатать
     * прямоугольник на консоль.
     *
     * Какие конструкторы вызываются при выполнении кода в следующем блоке?
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 1.10\n";

        Rect r1(1, 5, 8, 0), r2(-4, 1, 7, -1); //конструкторы с параметрами х2
        Rect r3 = bounding_rect(r1, r2); //параметры ф-ции вызывают 2 конструктора копирования + в функции создается объект при помощи конструктора с параметрами
        print_rect(r3);
    }

    /**
     * Задание 1.11. Поля объектов и свойства объектов.
     *
     * У нашего прямоугольника как сущности есть много свойств помимо координат
     * сторон, например, ширина, длина и площадь. До этого все свойства
     * прямоугольника однозначно отображались в его поля, однако, это не всегда
     * так.
     *
     * Добавьте в класс `Rect` методы `get_width()`, `get_height()` и
     * `get_square()`, возвращающие ширину, высоту и площадь соответственно,
     * при этом не вводя новых полей в класс.
     *
     * Некоторые из свойств могут быть доступны и на запись: добавьте методы
     * `set_width` и `set_height`, которые будут устанавливать ширину и высоту
     * прямоугольника, не меняя координаты точки с минимальными значениями X и
     * Y.
     *
     * Продемонстрируйте ниже работу этих методов.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 1.11\n";
        Rect r1(0, 5, 7, 1);
        print_rect(r1);
        r1.set_width(3);
        r1.set_height(4);
        print_rect(r1);
        std::cout<<"Ширина: "<< r1.get_width() << " Высота: "<< r1.get_height()<< " Площадь: " << r1.get_square() << std::endl; 
    }

    /**
     * Задание 2. Случаи применения объектов.
     *
     * Объект в языке С++ - инструмент широкого назначения, который может
     * использоваться в самых разных сценариях. Когда эти сценарии смешиваются,
     * это может привести к путанице и логическим ошибкам. В этом задании мы
     * обрисуем *некоторые* сценарии использования объектов.
     */

    /**
     * Задание 2.1. Объект как сущность предметной области.
     *
     * При решении задач из реального мира часто используют объекты для
     * моделирования в программе объектов из предметной области. В методах этих
     * объектов содержится логика, отражающая то, как программист моделирует
     * различные действия и отношения с объектами предметной области.
     *
     * Реализуйте класс `Barrel` в файлах `barrel.hpp` и `barrel.cpp`, который
     * реализует сущность бочки в следующей задаче.
     *
     * Даны две бочки известного объема. В одной бочке в начальный момент
     * времени содержится спирт (96%), в другой – вода. Кружкой емкостью 1л
     * переливаем итеративно содержимое из одной бочки в другую следующим
     * способом: на каждой итерации зачерпнули из первой бочки -> вылили во
     * вторую зачерпнули из второй бочки -> вылили в первую. Требуется
     * определить номер итерации, на которой концентрация спирта в первой бочке
     * станет меньше 50%.
     *
     * Реализуйте в классе методы, которые позволят псевдокоду в следующем
     * блоке превратиться в настоящий код и решить задачу.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 2.1\n";

        Barrel alch(100, 96); // бочка со спиртом
        Barrel water(100, 0);

        int iteration=0;
        while(alch.concentration() > 50)
        {
            alch.pour_in(water);
            water.pour_in(alch);
            iteration++;
        }
        std::cout<< "После " << iteration << " итерации\n";
    }

    /**
     * Задание 2.2. Объект как математическая сущность.
     *
     * Часто с помощью объектов реализуют математические сущности и операции с
     * ними, потому что обычно все действия с ними хорошо определены и известны
     * заранее.
     *
     * Реализуйте класс `Matrix` в файлах `matrix.hpp` и `matrix.cpp`, используя
     * код из лабораторной работы №5 прошлого семестра.
     *
     * Реализуйте следующие конструкторы:
     * - `Matrix(int n)` - инициализирует единичную матрицу размера n x n;
     * - `Matrix(int m, int n, double fill_value = 0)` - инициализирует матрицу 
     *   размера m x n, где все элементы будут равны `fill_value`;
     * - конструктор копирования.
     *
     * Реализуйте деструктор и следующие методы:
     * - `double get(int i, int j)` - получить значение элемента;
     * - `void set(int i, int j, double value)` - установить значение элемента;
     * - `int get_height()` и `int get_width()` - получить высоту и ширину
     *   соответственно;
     * - `void negate()` - операция `-A` для матрицы;
     * - `void add_in_place(Matrix &other)` - операция `this += other` для
     *   матрицы;
     * - `Matrix multiply(Matrix &other)` - возвращает результат матричного
     *   умножения.
     *
     * В случае несовместимых размеров матрицы выкиньте исключение с помощью
     * оператора `throw` (подробнее о нем мы будем говорить позже).
     *
     * Реализуйте ниже вычисление чисел Фибоначчи матричным способом с помощью
     * вашего класса, как это было сделано в прошлом семестре.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 2.2\n";
        
        Matrix ed_matr(3), matr1(3, 4, 2), matr2(4, 5, 1), matr3(3, 4, 3), matr4(ed_matr);

        ed_matr.print_matr();
        std::cout<<"Копия:\n";
        matr4.print_matr();

        try{ed_matr.set(5, 5, 5);}
        catch(const char* error){ std::cout << "Ошибка: " << error << std::endl;}

        try{std::cout<<ed_matr.get(5, 5)<< std::endl;}
        catch(const char* error){std::cout << "Ошибка: " << error << std::endl;}

        ed_matr.set(2, 2, 5);
        std::cout<<"Теперь эл-т (2;2) в единичной матрице равен "<< ed_matr.get(2, 2)<< std::endl;
        std::cout<< std::endl;
        ed_matr.negate();
        ed_matr.print_matr();

        std::cout<<"Матрица №1 имеет размеры: " << matr1.get_height() <<"x"<< matr1.get_width()<< std::endl;
        matr1.print_matr();
        matr1.add_in_place(matr3);
        matr1.print_matr();
        Matrix matr_mult = matr1.multiply(matr2);
        matr_mult.print_matr();

        try{matr1.add_in_place(ed_matr);}
        catch(const char* error){ std::cout << "Ошибка: " << error << std::endl;}

        try{Matrix matr_mult2 = matr1.multiply(ed_matr);}
        catch(const char* error){std::cout << "Ошибка: " << error << std::endl;}

        //Фиббоначи
        const int n = 40;
        long int fib[n+1];
        fib[0] = 0;
        fib[1] = 1;

        Matrix B(2, 2, 1), C(2, 1, 0); //матрица слева, по центру, справа
        B.set(2, 2, 0); //

        for(int i=2; i<n+1; i++){
            C.set(1, 1, fib[i-1]); //правая матрица
            C.set(2, 1, fib[i-2]);

            Matrix A = B.multiply(C); //левая матрица, равная произведению
            fib[i] = A.get(1, 1);
        }

        std::cout<< n<<"-е число Фиббоначи: " << fib[n] << std::endl;
    }


    /**
     * Задание 2.3. Объект - обладатель ресурса.
     *
     * Ресурсами - динамической памятью, файлами, сетевыми соединениями - нужно
     * управлять, как минимум, нужно не забывать их освобождать, когда они
     * больше не нужны. Для этого часто используют отдельные классы, которые
     * реализуют "грязную" работу по управлению ресурсами, а другие классы уже
     * использую их для реализации логики более высокого уровня.
     *
     * Такие объекты "обладают" ресурсом, это означает, что они и только они
     * ответственны за его освобождение. Это, в свою очередь, означает, что эти
     * объекты обязаны освобождать ресурс, когда объект больше не нужен (в
     * деструкторе) или когда им присваивают другой ресурс.
     *
     * В рамках этого задания необходимо реализовать класс строки, который
     * будет отвечать за динамическую память, на которой располагается эта
     * строка. Создайте класс `MyString` в соответствующих файлах.
     *
     * У класса должны быть конструкторы:
     *
     * - по умолчанию - создает "пустую" строку;
     * - с параметром `const char *` - объект выделяет память под копию этой строки.
     *
     * Добавьте следующие методы:
     * - `char get(int i)` - получение i-того элемента строки;
     * - `void set(int i, char c)` - установка i-того элемента строки;
     * - `void set_new_string(const char *str)` - замена текущего содержимого
     *   на новое;
     * - `void print()` - вывод строки на консоль;
     * - `void read_line()` - замена текущего содержимого строки на строку, считанную
     *   с консоли (неопределенного размера).
     *
     * Постарайтесь реализовать эти операции без выделения лишней памяти.
     * Продемонстрируйте ниже использование этого класса.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 2.3\n";
        MyString None, str1("Marks");
        std::cout<< "Нулевая строка: ";
        None.print();

        int i=1;
        std::cout<< "У строки ";
        str1.print();
        std::cout<< i << "-ый символ: " << str1.get(i) << std::endl;
        char CH = 'K';
        str1.set(i, CH);
        std::cout<<"Установим вместо него " << CH << ": ";
        str1.print();
        str1.set_new_string("Lenin");
        str1.print();
        std::cout << "Введите новое значение для строки: ";
        str1.read_line();
        str1.print();
    }

    /**
     * Проверьте, что ваша строка корректно работает в следующих ситуациях.
     */

    {
        MyString s1;
        MyString s2 = s1;
        MyString s3("This is my string");
        MyString s4 = s3;
    }

    /**
     * Задание 2.4. Объект-алгоритм.
     *
     * Частой практикой является разделение больших сложных функций на
     * несколько маленьких и простых функций, однако, иногда бывает сложно это
     * сделать, так как код на протяжении всех функции использует много общих
     * переменных. В таких случаях создают класс, полями которого делают эти
     * переменные, а функции становятся методами этого класса.
     *
     * Реализуйте ваш алгоритм переноса текста по словам из лабораторной работы
     * №3 прошлого семестра в виде такого объекта. Полями класса должны
     * являться переменные, которые объявлены вне циклов и используются внутри
     * них. Все логические условия (например, "строка закончилась") или
     * атомарные действия (например, "вывести содержимое буфера строки")
     * реализуйте методами класса.
     *
     * Примерное использование класса приведено ниже.
     */

    {
        std::cout<< std::endl;
        std::cout<< std::endl;
        std::cout<< "Задание 2.4\n";

        int line_width = 10;
        MyString input;
        input.read_line();
        std::cout<< std::endl;
        TextWrapper wrapper(input, line_width);
        wrapper.print_wrapped();
    }

    /**
     * Задание 3. Сборка проекта, Make-файлы.
     */

    /**
     * Задание 3.1. Создание Make-файла для сборки.
     *
     * Для выполнения задания в вашей среде Linux (WSL для Windows) вам
     * понадобится программа `make`. Проверьте, установлена ли она с помощью
     * команды `make --version`, если такой программы нет, установите ее (sudo
     * apt install make).
     *
     * Создайте файл с названием `Makefile`. В нем вы будете определять цели
     * сборки и необходимые шаги для сборки программы. Например, для сборки
     * отладочной версии вашей программы вам нужно выполнить вызвать программу
     * `g++` с нужными параметрами. Для этого в Makefile'е нужно указать цель и
     * шаги, например:
     *
     * ```
     * debug.out:
     *     g++ -g -o debug.out main.cpp rect.cpp barrel.cpp matrix.cpp my_string.cpp text_wrapper.cpp
     * ```
     *
     * Обратите внимание, что в Makefile используются символы TAB вместо пробелов.
     *
     * После этого можно запустить сборку командой `make debug.out`, вторым
     * параметром передается имя цели.
     */

    /**
     * Задание 3.2. Переиспользование целей.
     *
     * При определении цели вы можете указать цели, которые необходимо
     * выполнить сначала, а указанные шаги будут выполнены после. Например,
     * определим цель для запуска отладчика с нашей отладочной сборкой:
     * 
     * ```
     * debug: debug.out
     *     gdb debug.out
     * ```
     *
     * Теперь при выполнении цели `debug` сначала будет выполнена цель
     * `build_debug`, а только потом команда `gdb debug.out`.
     */

    /**
     * Задание 3.3. Структура проекта.
     *
     * Хорошей практикой является разделять файлы разного назначения по разным
     * директориям: файлы исходного кода помещаются в папку `src` (source), исполняемые
     * файлы и промежуточные результаты сборки помещаются в папку `build` (или `out`),
     * Makefile обычно находится в корневой директории проекта.
     *
     * Приведите вашу директорию в такой вид и поправьте команду сборки.
     */

    /**
     * Задание 3.4. Частичная пересборка.
     *
     * Целью использования Make-файлов является частичная пересборка: с помощью
     * этой системы сборки можно перекомпилировать только те файлы, которые
     * изменились с прошлой сборки. Чтобы это работало, нужно чтобы каждый .cpp 
     * файл собирался в отдельный .o файл. Например, определим такое правило для
     * сборки файла `rect.cpp`:
     *
     * ```
     * build/rect.o: src/rect.cpp src/rect.hpp
     *     g++ -g -c -o build/rect.o src/rect.cpp
     * ```
     *
     * Цель `build/rect.o` будет выполняться, если файла `build/rect.o` нет или
     * если файлы `src/rect.cpp` и `src/rect.hpp` были изменены после сборки
     * файла `build/rect.o`.
     *
     * Создайте правила для сборки файлов `build/my_string.o`, `build/barrel.o`
     * и `build/text_wrapper.o`. После этого создайте правило для сборки
     * отладочной сборки:
     *
     * ```
     * build/debug.out: build/rect.o build/my_string.o build/barrel.o build/text_wrapper.o src/main.cpp
     *    g++ -g -o build/debug.out src/main.cpp build/rect.o build/my_string.o build/barrel.o build/text_wrapper.o
     * ```
     *
     * Обновите цель `debug`, чтобы она использовала цель `build/debug.out`.
     *
     * Убедитесь в том, что при изменении отдельных файлов программы происходит
     * частичная компиляция только нужных файлов.
     */

    /**
     * Задание 3.5*. Делаем Make-файл удобнее.
     *
     * Ознакомьтесь c документацией к программе `make` [1] (как минимум,
     * прочитайте раздел 2) и воспользуйтесь рекомендованными практиками для
     * того, чтобы сделать ваш Make-файл удобнее. Опишите в комментариях, что
     * вы сделали.
     *
     * 1: https://www.gnu.org/software/make/manual/html_node/index.html
     */
    /*
    1) Добавлно clean, которое очищает папку build
    2) Добавлена переменная objects, в которой хранятся все названия объектных файлов + flags с флагами
    3) Добавлено создание папки build, если ее нет
    4) Добавлена цель по умолчанию (просто компиляция при make)
    */

    /**
     * Задание 3.6. Проверка утечек памяти.
     *
     * Сделайте цель `build/leaks.out`, в которой будет собираться версия
     * программы для проверки утечек памяти, и цель `leaks`, где на вход
     * программе `build/leaks.out` будет подаваться файл с пользовательским
     * вводом для вашей программы.
     */

    /**
     * Задание 4. Автоматическое тестирование программы.
     *
     * Для проверки правильности работы отдельных частей большой программы
     * часто пишут модульные тесты (unit tests). Эти тесты являются отдельным
     * исполняемым кодом, которые не включается в основную программу, а идет
     * "сбоку". Самым простым вариантом модульного теста является программа,
     * которая делает различные проверки с вашим модулем, после чего возвращает
     * 0, если тест пройден, или не 0, если тест провален.
     */

    /**
     * Задание 4.1. Проверка простых методов класса Rect.
     *
     * Создайте директорию `tests` и файл `tests/test_rect_basic_methods.cpp`.
     * В этом файле создайте функцию `main`, в которой проверьте, что после
     * использования разных конструкторов и метода `set_all` методы `get_left`,
     * `get_right`, `get_bottom` и прочее возвращают правильные результаты.
     *
     * Проверки можно делать с помощью макроса `assert` из файла `cassert`
     * стандартной библиотеки. После всех проверок функция `main` должна
     * возвращать 0.
     *
     * Создайте цель для сборки файла `build/test_rect_basic_methods.out`
     * и проверьте вручную, что все тесты проходятся.
     */

    /**
     * Задание 4.2. Проверка других функций.
     *
     * Создайте файл `tests/test_rect_properties.cpp`, в котором проверьте, что 
     * методы `get_width`, `get_height`, `get_square`, `set_width` и `set_height`
     * работают, как ожидается.
     *
     * Создайте файл `tests/test_rect_operations.cpp`, в котором проверьте, что 
     * методы `move` и `inflate` работают, как нужно.
     *
     * Создайте файл `tests/test_bounding_rect.cpp`, в котором проверьте на 
     * нескольких случаях, что функция `bounding_rect` работает, как ожидается.
     * Обратите внимание, что пользователь может перепутать "лево" и "право"
     * при вводе, аналогично - "верх" и "низ". Обработайте эту ситуацию и 
     * добавьте тест для проверки этого случая.
     */

    /**
     * Задание 4.3. Запуск всех тестов.
     *
     * Создайте цели для сборки всех тестов из задания 4.1 и 4.2. Создайте цель
     * `test`, в которой будут запускаться все тесты из этих заданий.
     *
     * Проверьте, что все тесты проходятся при помощи команды `make test`.
     */

    /**
     * Задание 4.4*. Рефакторинг.
     *
     * Когда код хорошо покрыт тестами, можно попробовать как-то улучшить его
     * внутреннее убранство. Посмотрите внимательно на реализацию класса `Rect`
     * и постарайтесь сделать ее "красивее" - убрать лишние повторения кода,
     * длинные функции и тд. Этот процесс называется *рефакторингом*
     * (переработкой).
     *
     * После каждого изменения убеждайтесь, что тесты все еще проходятся.
     */


    /**
     * Задание 5. Сюжетный поворот.
     *
     * Представим, что после раунда обсуждения с коллегами вы решили, что для
     * некоторых целей не очень удобно прямоугольник левой, правой, нижней и верхней
     * границей, а гораздо удобнее хранить координаты левой нижней точки, а также
     * высоту и ширину.
     *
     * Измените реализацию класса `Rect` соответствующим образом, оставляя в
     * комментариях старую реализацию.
     *
     * Убедитесь, что тесты все еще проходятся.
     *
     * Отметьте, какие части программы вам пришлось поменять. Если вы правильно
     * пользовались инкапсуляцией, то все изменения должны были произойти
     * *только* внутри класса, а остальные части программы (в частности,
     * функция `bounding_rect`) должны были остаться без изменений.
     *
     * Если вы провели хороший рефакторинг в задании 4.4, то изменений должно
     * было быть не так много.
     */

    return 0;
}
